<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    /*
        5.箭头函数
            一种函数的简写方式
            1.let fn = () => {}   没有参数
            2.let fn = (a,b,c) => {} 多个参数
            3.let fn = a => {} 一个参数
            4.let fn = a => a; return a

        箭头函数的this，跟它的执行上下文有直接的关系。

        箭头函数的this找老爹。

        6.this
        7.arguments
            实参的集合
            function fn(){
                console.log(arguments);//[1,2,3,4,5]
            }
            fn(1,2,3,4,5)

            箭头函数中没有arguments

        8.闭包

        var -> let

    */   
//    function fn(){}
    // let fn = function(){}
    // let fn = () => {
    //     alert(1);
    // }
    // let fn = e => {
    //     alert(e);
    // }
    // let fn = e => {
    //     return e; 
    // }
    // let fn = (a,e) => e;

    // let fn = (e) => {
    //     console.log(e);
    //     alert(e);
    //     console.dir(1);
    // }

    // let fn = e => e;
    // let fn = () => alert(1);
    // fn(5);
    // console.log( fn(5) );

    // document.onclick = function(){
    //     // let fn2 = () => {
    //     let fn2 = function(){
    //         let fn = () => {
    //             console.log(this);
    //         };
    //         fn();
    //     }
    //     fn2();
    // }

    // console.log(this);//window

    // function fn(){
    //     console.log(this);//window
    // }
    // fn();

    // let obj = {
    //     fn:function(){
    //         console.log(this);//obj
    //     }
    // }
    // obj.fn(); 

    // document.onclick = fn();
    
    // function fn(){
    //     return function(){
    //         console.log(this);
    //     }
    //     // fn2();
    //     // console.log(this); //document
    // };


    // var name = '小海丽';

    // let obj = {
    //     name:'智鹏哥哥',
    //     fn:function(){
    //         // this.name = {};
    //         console.log(this.name); //''
    //     }
    // }
    // //定时器里的this属于window
    // setTimeout(obj.fn, 1000);


    // let fn = () => {
    //     console.log(this);
    // }
    // fn();


    /*
        闭包:
            函数形成一个不销毁的作用域，这个作用域就叫闭包
        
        var sMessage = "hello world";

        function sayHelloWorld() {
            alert(sMessage);
        }

        sayHelloWorld();
        closure 闭包
    */

    // var sMessage = "hello world";

    // function sayHelloWorld() {
    //     alert(sMessage);
    // }

    // sayHelloWorld();

    // console.dir(sayHelloWorld)

    /*
        闭包:
            函数套函数，子函数使用父函数的参数或者变量
            并且子函数被外界所引用，此时父级形成闭包环境
            父级的参数或者变量不被浏览器垃圾回收机制回收.
            此时，打印父函数的返回值，有个属性为Scopes
            Scopes下有个closure的属性，closure 就是闭包。

        使用闭包可以一直存储父级的参数或者变量
        不被外界的函数或者变量所干扰（污染）

    */
    function fn(){
        let a = 0;
        function fn2(){
            console.log(a);
        }
        function fn3(){

        }

        console.dir(fn3);
        return fn2;
    }
    let f = fn();
    console.dir(f);

</script>
</body>
</html>