<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>







       //24.模块化开发(3个)
       //1)在团队协作开发的时候，我们经常会把一个复杂页面，按照具体的功能划分称为几大块，然后分别去开发，开发结束之后将代码合并到一起，这种模块划分的思想就是模块化开发思想
       //2)多人协作开发出现的问题：变量名、函数名冲突
       //3)真实项目中，我们可以使用单例模式（建议也是使用单例模式）来实现模块化开发

       //25. 单例模式(Singleton Pattern)(3个)
       //1)定义：把描述同一件事物的属性或者方法存放在某一个对象[命名空间(nameSpace)]中，多个对象[命名空间(nameSpace)]中的属性和方法是互不干扰的,这种设计模式叫做单例模式 (把对象数据类型实现"把描述同一件事物的属性或者特征归纳汇总在一起，以此避免全局变量冲突问题"的方式和思想叫做："单例设计模式")
       //2)好处：不受全局变量的污染和干扰，并且可以相互调用方法
       //3)由来：单例模式的本质就是一个对象，它是Object类上的一个实例，实例与实例之间互相不干扰，叫做单独的实例，简称单例
       //singleton不仅仅是对象名了，在单例模式中，singleton称之为"命名空间(nameSpace)"
       /* var sinleton={
            xxx:xxx
            //在当前的命名空间下调取其它命名空间的方法：指定好对应的命名空间名字即可，使用[nameSpace].[property]就可以操作了
            //调取本模块中的一些方法，可以直接使用this处理即可：此方法中的this一般都是当前模块的命名空间
        }*/

       //26 高级单例模式(3种)
       //1)基于JS高阶编程技巧'惰性思想' 来实现的单例模式，并且可以把一些常用的设计模式(例如：'命令模式、发布订阅设计模式、promise设计模式'等)融合进来，最后清晰的规划我们的业务逻辑代码，方便后期二次开发和维护，这种设计思想综合体就是高级单例模式，也是项目中最常应用的
       //2)在高级单例模式当中，我们不只会把一个对象赋值一个命名空间，我们会让它先执行一个自执行函数[形成了一个闭包，一个不销毁的作用域]，在自执行函数中，返回一个对象给这个命名空间
       //3)好处：我们可以在这个私有的作用域中，创建很多属性和方法，仅需要把我们使用的属性和方法暴露在这个对象当中即可
       /*
       var utils = (function () {
           var  newAry = [];// 私有变量
           function unique(ary) {
               for(var i=0;i<ary.length;i++){
                   var cur = ary[i];
                   if(newAry.indexOf(cur)===-1){
                       newAry.push(cur)
                   }
               }
               return newAry;
           }
           function sortMy() {
               // 上一级作用域是自执行函数形成的作用域；
           }
           return  {
               unique:unique,
               sortMy:sortMy
           };
       })();
       console.log(utils.unique(ary));
       console.log(utils.sortMy(ary));*/

       //27 面向对象(OOP)(5种)
       //1)面向对象是编程思想。定义：面向类的封装、继承和多态，通过简单实例化，调用其方法和属性
       //2)对象：编程语言中的对象是一个泛指，**万物皆对象**(我们所要研究、学习以及使用的都是对象)(对象数据类型是对象的一种，但对象不是对象数据类型，它只是一个抽象的泛指)
       //3)类 ：对象的具体细分(按照属性或者特征细分为一些类别) (对象中具有同一属性和特征的集合，我们称之为类，类又分为大类和小类) ??小类算不算大类的一个实例
       //4)实例：某一类中具体的事物  (实例是类中的一个具体的事物，我们研究当前实例具有哪些属性和方法，那么证明当前类中的其他实例也同样具有这些属性和方法)
       //5)JS本身就是基于面向对象创造出来的语言(所以它是面向对象编程)，我们想要学习JS，首先也是给其进行分类，我们拿出某一类中的实例，进行学习和研究，如果这个实例具备一些特点和特征，那么这个类的其他实例也具备这些特点和特征

       //28 JS中一些常用的内置类(3种)
       //2)关于元素对象的
       //Object:对象类
       //EventTarget:事件目标类
       //Node:节点类
       //Element:元素(标签)类
       //HTMLElement:HTML元素(标签)类
       //HTMLDivElement:HTMLDiv元素(标签)类   (每一个HTML标签都有一个自己所属的内置类)

       //Object:对象类
       //EventTarget:事件目标类
       //Node:节点类
       //Document:Document类
       //HTMLDocument:HTMLDocument类

       //3)关于元素集合
       //HTMLCollection:元素集合类(getElementsByTagName/ByClassName/querySelectorAll)
       //NodeList: 节点集合类(getElementsByName/childNodes)


       //29 目前阶段学习面向对象对于我们的意义(2种)
       //1)它是谁，是哪个类的一个实例，这个类提供了哪些东西，如果这个类没有提供一些方法，我们想用的话怎么去添加这些方法，它跟哪些类有什么关系，这个类和其他类有什么关联，如果有关联的话是怎么回事，它所有的父类都有哪些
       //2)研究数组：
       //2.1)创建一个数组类的实例，研究其基础语法和结构
       //2.2)如果想要研究数组具备的功能方法，我们只需要看Array/Object这些类上都赋予了它什么样的方法

       //42 在浏览器中，禁止调用Null类和Undefined类

       //42 链式写法：执行完成之后一个方法紧跟着就调取下一个方法(执行完成一个方法后，返回的结果依然是当前类的实例，这样就可以继续调取当前类的其他方法操作了)

       //exec捕获到结果的格式：
       //1)获取的结果是一个数组
       //2)数组中的第一项是当前本次大正则在字符串中匹配到的结果
       //3)index:记录了当前本次捕获到结果的起始索引
       //4)input:当前正则操作的原始字符串
       //5)如果当前正则中有分组，获取的数组中，从第二项开始都是每个小分组本次匹配到的结果(通过exec可以把分组中的内容捕获到)
       //6)执行一次exec只能把符合正则规则条件中的一个内容捕获到，如果还有其他符合规则的，需要再次执行exec才有可能捕获到

       //正则捕获存在懒惰性
       //1)执行一次exec捕获到第一个符合规则的内容，第二次执行exec，捕获到的依然是第一个匹配的内容，后面匹配的内容不管执行多少次exec都无法捕获到
       //2)解决正则捕获的懒惰性：在正则的末尾加修饰符g(全局匹配)

       //使用字符串match捕获：
       //1. 如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到
       //2. 如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到
       //3. 局限性：在加了修饰符g的情况下，执行match方法只能把大正则匹配的内容捕获到，对于小分组捕获的内容，方法给其自动忽略了。

       //45 所有的函数(类也是函数)都可以调取Function.prototype的方法：call/apply/bind
       // 所有的对象(函数也是对象)都可以调取Object.prototype的方法：toString/hasOwnProperty

       //96 原型的继承(2个)
       //1) 让子类的原型指向父类的实例
       //2) 子类不仅可以继承父类原型上的公有属性和方法，而且父类提供给父类实例的私有属性和方法，也被子类继承了(子类实例可以调用父类原型上的公有属性和方法，也可以调用父类提供给父类实例的私有属性和方法)
       //细节：1）我们首先让子类的原型指向父类的实例，然后再向子类原型上扩展方法，防止提前增加方法，等原型重新指向后，之前在子类原型上扩展的方法都没用了(子类原型已经指向新的空间地址了)
       //2) 让子类原型重新指向父类实例，子类原型上原有的constructor就没有了，为了保证构造函数的完整性，我们最好给子类的原型重新手动设置constructor属性
       /*function Parent() {
           this.x=100;
       }
       Parent.prototype.getX=function () {
           console.log(this.x);
       }
       function Children() {
           this.y=200;
       }
       **Children.prototype=new Parent();**
       Children.prototype.getY=function () {
           console.log(this.y);
       };
       var child=new Children();
       console.log(child.y);   //200
       console.log(child.x);   //100
       child.getY();     //  200
       child.getX(); */   //  100

       //97 call继承(2个)
       //1) 在子类的构造体中，把父类做普通方法执行，并且让父类方法中的this指向子类的实例
       //2)原理：把父类构造函数中提供给父类实例的私有属性和方法，原封不动复制了一份给子类的实例（继承完成后，子类和父类是没关系的）(子类的实例只继承了父类提供给父类实例的私有属性和方法，不会继承父类提供给父类实例的公有属性和方法)
       //细节：我们一般把call继承放在子类构造函数中的第一行，也就是创建子类实例的时候，进来的第一件事情就是先继承，然后再给子类实例赋值自己私有的属性和方法(好处：自己设置的可以把继承过来的结果替换掉)
       /*function Parent() {
           this.x=100;
       }
       Parent.prototype.getX=function () {
           console.log(this.x);
       }
       function Children() {
           //=>this:child  子类的实例
           **Parent.call(this); ** //让Parent执行，方法中的this依然指向子类的实例(在父类的构造函数中写的this.xx=xxx都相当于在给子类的实例增加一些私有的属性和方法)
           this.y=200;
       }
       var child=new Children()*/

       //98  Object.create(obj)(1个)
       //1) 创建一个空对象(实例)，并且把实例的__proto__指向obj
       /* var obj={name:'zf'};
        var newObj=Object.create(obj);
       console.log(newObj.__proto__ === obj);*/    //true

       //99 寄生组合继承
       //1)子类公有的继承父类公有的(原型继承的变通)
       //2)子类私有的继承父类私有的(call继承完成)
       function Parent() {
           this.x=100;
       }
   Parent.prototype.getX=function () {
       console.log(this.x);
   }
   var obj=Object.create(Parent.prototype);
   console.log(obj instanceof Parent);  //true
   function Children() {
       Parent.call(this);
       this.y=200;
   }
   Children.prototype=Object.create(Parent.prototype);
   Children.prototype.constructor=Children;
   Children.prototype.getY=function () {
       console.log(this.y);
   }


   //Promise (7种)
   //1) Promise 是异步编程的一种解决方案
   //2) 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
   //3) Promise对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。
   //4) 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）
   //5) Promise 是一个构造函数，new 会创建一个Promise实例，需要传一个回调函数给Promise，回调函数需要接收两个参数
   /*let pro= new Promise(function (resolve,reject) {
       /!* if () {//如果异步操作成功，执行resolve
            resolve()
        } else{  //如果异步操作失败，执行reject()
            reject()
        }*!/
        setTimeout(function () {
            let val =Math.random()
            if (val>0.5){
                console.log(3);
                resolve(val)
            } else {
                reject(val)
            }
        },1000)
    })*/
   //6)then: 是Promise原型上的方法；只有Promise的实例可以调用
   //7)then 传了两个函数； 第一个是必须要有的；第二个是可选的
   /* pro.then(function (value) {
        //当调用resolve时，当前函数运行
        console.log(1);
        console.log(value);
    },function (val) {
        //当调用reject时，此函数运行
        console.log(2);
        console.log(val);
    })*/


</script>
</body>
</html>

