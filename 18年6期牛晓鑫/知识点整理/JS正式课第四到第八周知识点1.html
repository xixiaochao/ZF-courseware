<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//1.单线程与多线程(4个)
//1)单线程：一次只能执行一个任务，不能同时执行多个执行
//2)多线程：一次可以同时执行多个任务
//3)js是单线程的
//4)浏览器是多线程的

//2. 同步编程(sync:synchronize) (1个)
//1）浏览器会把当前的任务执行完毕，才会继续执行下一个任务

//3. 异步编程(async) (1个)
//1)浏览器在当前的任务没有执行完毕时，会继续执行下一个任务

//4. 异步编程有(4个)
//1)微任务：
//1.1）Promise实例的then方法、
//1.2） async函数的await下面的任务
//1.2.1) async函数默认返回一个Promise的实例，因此返回值可以调用then方法
//2)宏任务：
//2.1) ajax中的异步编程
//2.2) 定时器
//2.3) 所有的事件绑定
//2.4) 回调函数

//5. 同步异步编程的核心原理(4个)
//1)浏览器会把所有的任务分成两个任务队列：主任务队列和等待任务队列
//2)只有当主任务队列的任务都执行完毕后，才会去执行等待队列中的任务
//3)当主任务队列的任务执行完毕后，会去等待任务队列中，找到已经到达时间的任务，谁先到达先找谁，同时到达的看谁先创建，拿到主任务队列中执行，当前任务执行完毕后，再去等待任务队列中找其他任务
//4)异步任务分为微任务和宏任务，先把微任务挨个执行，再去执行宏任务
//5)微任务有：Promise实例的then方法、async函数的await下面的代码
//6)宏任务有：定时器。。。
//7)
//8)

//6. 匀速运动的公式(2个)
//1)目的：计算出当前最新的位置
//2)公式：function linear(t,b,c,d){return t/d*c+b}

//7. 可枚举属性与不可枚举属性(2个)
//1)可枚举属性：对象上的私有属性和对象所属类的原型上的自定义的属性都是可枚举属性，for in会遍历出所有的可枚举属性
//2)不可枚举属性：对象所属类的原型上的内置属性都是不可以枚举属性，for in不会遍历出来
/*function Fn() {
    this.a=2;
    this.b=3;
}
var obj=new Fn;
Fn.prototype.gn=function () {
    console.log(2);
}
for (var key in obj){
    console.log(key);   //a  b  gn
}*/

//8) for循环的作用域(1个)
//1)在for循环时，首先会形成一个父作用域，循环每执行一次，会形成一个子作用域，子作用域存储了变量，不受外界干扰，变量之间互不影响
/*for(let a=0;a<5;a++){
    // let a : 不是全局的；
    // 第一个子作用域a=0；
    // 第二个子作用域a=1;
    // 第n个子作用域....
    oLis[a].onclick = function () {
        console.log(a);
    }
}
console.log(a);*/

//9. 块级作用域 (6个)
//1){}会形成块级作用域，对象除外
//2)形成块级作用域的有：if else;  for;  for in;  while;  try catch;...
//3)块级作用域中的函数只声明不定义，外界可以调用
//4)一进到块级作用域，首先对块级作用域中的函数进行赋值
//5)块级作用域中带var的变量，外界可以调用
//6)块级作用域中带let的变量，外界不可以调用
/*console.log(gn);  //==>  undefined
if (true){
    let a=15;
    var b=10;
    function gn() {
        console.log(1);
    }
}
console.log(b);   //10
console.log(gn);  //  f gn(){console.log(1)}
console.log(a);  // a is not defined*/

//10. 解构赋值 (4个)
//1)如果变量没有对应的解构值，默认解构出undefined
/*let [x,y,z]=[1,2];
    console.log(x);   //1
    console.log(y);   //2
    console.log(z);   //undefined*/
//2)等号两边的结构要保持一致
/*  let [a,[b],[c]]=[1,[2],[3]]
  console.log(a);   //1
  console.log(b);   //2
  console.log(c);   //3*/
//3)如果等号右边的值不是一个可遍历的值，那么会报错
/*let [f] = 1;
console.log(f);*/     //TypeError: 1 is not iterable
//4)变量可以赋初始值，如果等号右边有对应的解构值，会把初始值覆盖
/* let[foo=true]=[];
  console.log(foo); */ //true
// let[goo=true]=[1,2];
// console.log(goo);   //1

//11. 数组的解构赋值 (1个)
//1)按照数组的顺序进行解构

//12. 对象的解构赋值 (2个)
//1)按照对象的属性名进行解构
/* let {a,b,c}={a:1,b:2,c:3};
   console.log(a);  //1
   console.log(b);  //2
   console.log(c);  //3*/
//2)如果对象的属性名和属性值一样，可以只写一个
 /* var name="zf";
   var obj={name:name};
   var obj1={name}
   console.log(obj);    //{name:"zf"}
   console.log(obj1);*/   //{name:"zf"}

//13. 字符串的解构赋值 (2个)
//1)会按照数组的顺序进行解构
/* let [a,b,c,d,e]="hello";
    console.log(a);      //"h"
    console.log(b);      //"e"
    console.log(c);      //"l"
    console.log(d);      //"l"
    console.log(e);     // "0"
//2) 解构出字符串的长度  let {length}="hello"

//14. 函数的扩展 (2个)
//1)在es6之后，函数形参可以赋初始值，如果有对应的实参，会把初始值覆盖
/*function fn(x=100,y) {console.log(x)}    fn()  //==>100
function fn(x=100,y) {console.log(x)}   fn(1,2)   //==>1
function fn([x,y]){console.log(x);console.log(y)};  fn([1,2])  //==>1,2
function fn({x,y}) {console.log(x); console.log(y);}   fn({x:1,y:2})*/  //==>1,2
//2)形参和实参都可以...来传递和接收参数
/*function fn(...ary) {console.log(ary)}    fn(1,3,6)  //==>[1,3,6]
function gn(a) {console.log(a);}     gn(...[1,2]) */   //==>1

//15. 箭头函数 (4个)
//1)把function关键字省略，在小括号和大括号之间加了箭头符号=>
/*let fn1 =()=>{console.log(100);}
fn1();
//2)如果函数只有一个形参，可以省略函数定义时的小括号；如果没有或者大于1个形参，则不可以省略函数定义时的小括号
// let fn3 = a =>{console.log(a);}
// fn3(2);
//3)如果函数体中只有一个语句，可以省略大括号
let fn4=(a,b)=> console.log(a);
    fn4(1);  */
//4)如果函数体中只有return语句，可以省略return，但如果return的是一个对象，在省略return时要在外面加一个小括号
// let fn6=(a,b)=> a;
// console.log(fn6(100));      //100
// let fn8=(a,b)=>({a:1,b:2});
// console.log(fn8());       //{a:1,b:2}

//16. 普通函数和箭头函数的区别 (4个)
//1)箭头函数自身没有this，箭头函数出现的this指向函数定义时所在的作用域中的this指向
//2)箭头函数不能作为构造函数，不能被new
//3)箭头函数没有arguments
//4)箭头函数不能作为Generator函数，不能使用yield命令
/*let obj = {
    fn:function f() {
        console.log(this);// obj
        box.onclick =()=>{
            console.log(this);// obj
        }
    }
}
obj.fn();*/
/*let ary = [1,3,4];
ary.map(()=>{
    // 箭头函数执行时，外层作用域是map执行形成的私有作用域，map作用域中的this指向ary; 但是箭头函数中的this，跟箭头函数在哪执行没有关系，只跟在哪定义有关；
    console.log(this);// window   window   window
})*/

//17. 数组的扩展 (3个)
//1) 扩展运算符
//1.1)展开数组、对象
//1.2)把类数组转为数组
//let ary=[1,2,3];  console.log(...ary);  //==>  1   2   3
//let a=[1,4];  let b=[3,50];   let newAry=[...a,...b];  console.log(newAry); //==> [1, 4, 3, 50]
//let obj1={a:1,b:2}; let obj2={c:3}; let obj3={...obj1,...obj2};  console.log(obj3); ==>{a: 1, b: 2, c: 3}
//function fn() {let a=[...arguments] ;console.log(a);}  fn(1,2,3);  //  a==> [1, 2, 3]
//2) Array.from()
//2.1)把类数组转为数组
//2.2)from方法是Array的私有属性
//function fn() { let a=Array.from(arguments); console.log(a);}   fn(1,2) //a==>[1, 2]
//3) Array.of()
//3.1)把一组数转为数组
//3.2)of方法是Array的私有属性
//console.log(Array.of(1, 3, "a"));   //==>  [1, 3, "a"]

//18 class (2种)
//1)ES6之前创建类的方法(4个)
/*function Person(name,age) {
    //(1)类new执行的时候，类中的this执行当前类的实例，this.xx=xxx是在给当前类的实例增加私有属性和方法
    this.name = name;
    this.age = age;
}
//(2)在类的原型上的属性和方法，属于类的实例的公有属性和方法
Person.prototype={
    constructor:Person,  //(3)类的原型重新指向后，需要重新设置constructor，指向当前类，保证机制的完整性
    say:function () {
        console.log(`my name is ${this.name},i am ${this.age} years old`);
    }
}
//(4)把类当做普通对象，给类增加私有属性和方法，类的实例不能调用
Person.study = function () {
    console.log(`good good study, day day up`);
}
var p1 = new Person("小黄人",80);
console.log(p1); */  //{name:"小黄人",age:80};

//2)ES6中创建类的方法(7个)
//(1)用class创建的类不存在变量提升
//console.log(Person); //ReferenceError: Person is not defined
//(2)用class创建的类不能作为普通函数执行，只能new执行
/*class Person{
    constructor(name="zhufeng",age=9){
        //(3)类new执行的时候，类中的this执行当前类的实例，this.xx=xxx是在给当前类的实例增加私有属性和方法
        //(4)给类传递参数时，用constructor来接收
        this.name=name;
        this.age=age;
    }//(5)直接在大括号中写的属性和方法是设置在类的原型上，是给当前类的实例的公有属性和方法
    say(){
        console.log(`my name is ${this.name},i am ${this.age} years old`);
    }
    //(6)要把类当做普通对象，给其增加私有属性和方法，只需要在增加的属性和方法前加static即可
    static study(){
        console.log(`good good study, day day up`);
    }
}
let p1 = new Person("小黄人");
p1.say();   //my name is 小黄人,i am 9 years old
//(7)

console.log(Person.prototype.constructor === Person); */ //true
//Person();   //TypeError: Class constructor Person cannot be invoked without 'new'

//19. ES6中类的继承extends(4个)
/*class B{
    constructor(...ary){
        let [x=0,y=0]=ary;
        this.x=x;
        this.y=y;
    }
    sum(){
        return this.x+this.y;
    }
    static gn(){

    }
}
class A extends B{
    //1)创建A类，让A类继承B类
    //2)B类给实例的私有属性和方法会继承过来给A类的实例，作为A类的实例的私有属性和方法
    //3)A类的实例的__proto__指向A类的prototype，A类的prototype的__proto__指向B类的prototype
    constructor(...ary){
        //可以不写constructor,浏览器默认会创建它，而且默认把父类给实例的私有属性继承过来，而且把传给子类的参数值也传递给父类
        //写了constructor，this指向当前类的实例，this.xx=xxx是给类的实例增加私有属性
        super(...ary);  //4)super()必须写在constructor里面的第一行，super()里的参数是传递给被继承类
        let [,,z]=ary;
        this.z=z;
    }
    //直接在大括号中写的方法都设置在类的原型上，相当于给子类的实例增加公有的属性和方法
     fn(){

     }
}
let c = new Child(10,20,30);
console.log(c); */  //{x: 10, y: 20}

//20 Generator函数 (5种)
//1)Generator函数是一种异步编程解决方法
//2)Generator函数有两个特征：(1)关键字function和函数名之间有一个星号;(2)函数体内部使用yield表达式，来定义不同的内部状态
//3)调用Generator函数时，函数并不执行，而是返回一个遍历器对象，代表函数内部的指针
//4)遍历器对象调用next方法执行时，会从函数头部或上一次停止的地方继续向下执行，并且返回一个有着属性名为value和done的对象，value的属性值是yield表达式后面的值，代表函数内部的状态；done的属性值是一个布尔值，代表遍历是否结束
//5)yield表达式是暂停执行的标记，next方法执行可以恢复函数执行
/*function* helloWorldGenerator() {
    let a = 10;
    yield a;
    yield 'world';
    return 'ending';
}
var hw = helloWorldGenerator();
console.log(hw);       //  helloWorldGenerator {<suspended>}
console.log(hw.next());// {value: 10, done: false}
console.log(hw.next());// {value: "world", done: false}
console.log(hw.next());// {value: "ending", done: true}
console.log(hw.next()); *///{value: undefined, done: true}

//21. Promise (9个)
//1)Promise是es6新增的一个类，是一种解决异步编程的方法
//2)new Promise执行时需要传一个回调函数，回调函数中有两个参数resolve，reject
//3)Promise本身是同步的，new Promise中的回调函数会马上执行
//4)new Promise执行时，会创建出一个promise的实例，实例可以调用then方法，then方法是异步的，then方法需要传两个参数，第一个是必须的，第二个可有可无
//5)当new Promise中异步成功时，会调用resolve执行和then方法中第一个参数执行; 当异步失败时，会调用reject执行和then方法中第二个参数执行
//6)then方法执行后会默认返回一个Promise的实例，因此可以链式调用then方法，并且默认返回异步成功
//7)链式调用then方法时，如果没有return或者return的不是一个Promise的实例，那么从第二个以后的then方法后会根据new Promise的异步成功与否执行相应的参数；如果return一个Promise的实例，那么会根据return的Promise的实例的异步成功与否执行相应的参数
//8)
//9)

/*let p = new Promise(function (resolve, reject) {
    console.log(100);
    if (Math.random()<0.6) {
        resolve();
    }else {
        reject();
    }
    /!*setTimeout(function () {
        console.log(99);
        if (Math.random()<0.6) {
            resolve();
        }else {
            reject();
        }
    },2000)*!/
});
console.log(101);
p.then(function () {
    console.log(102);
},function () {
    console.log(103);
})
console.log(104);*/
/*function getDate(url) {
    let promise = new Promise(function (resolve, reject) {
        let xhr= new XMLHttpRequest();
        xhr.open("get",url,false);
        xhr.onreadystatechange=function () {
            if (xhr.readyState ===4 && xhr.status===200){
                resolve(xhr.responseText);
            } else {
                reject(xhr.statusText)
            }
        }
    })
    return promise;
}
getDate("data.json").then(function (data) {
    console.log(data);
},function (data) {
    console.log(data);
})*/
/*function getDate(url) {
    let promise = new Promise(function (resolve, reject) {
        let xhr= new XMLHttpRequest();
        xhr.open("get",url,true);
        xhr.onreadystatechange=function () {
            // 2  3   4
            if (xhr.readyState !==4) {
                return;
            }
            if (xhr.status===200){
                resolve(xhr.responseText);
            } else {
                reject(xhr.statusText);
            }
        }
    })
    return promise;
}
getDate("data.json").then(function (data) {
    console.log(data);
},function (data) {
    console.log(data);
})*/

//22. Proxy (4种)
//1)是给目标对象加了一层拦截器，当外界访问目标对象时，会首先经过拦截器，这样可以实现对外界访问进行过滤和改变
//2)new Proxy执行时需要传两个参数，第一个参数是目标对象，第二个参数是一个对象，里面有属性名分别是get和set的两个键值对
//3)当获取目标对象的属性名对应的属性值时，会触发get对应的函数执行
//4)当设置(新增或修改)对象的属性名对应的属性值时，会触发set对应的函数执行
/*let obj= new Proxy({a:1,b:"you are beautiful"},{
    //两个键值对；一个是get, 一个是set，名字不能更改
    get:function () {
        //当获取对象属性名对应的属性值，会触发这个get对应的函数执行，
        console.log("你很帅");
        return 100;
    },
    set:function () {
        //当设置(修改或新增)对象的属性时，会触发这个set对应的函数执行；
        console.log("我很帅")
    }
})
console.log(obj);        //{a: 1, b: "you are beautiful"}
console.log(obj.a);     //"你很帅"  100
console.log(obj.a++);*/  // "你很帅"  "我很帅"  100











//23. 事件 (2种)
//1)元素天生自带的行为，不是后期新增的，当我们操作元素时，会触发元素的很多事件，让事件绑定的方法执行
//2)元素的事件行为如果没有绑定方法，默认属性值为null
/*let oBox=document.getElementById("box");
console.log(oBox.onclick);*/  //-->null

//24. 事件绑定 (1种)
//1)给元素的事件绑定某个方法，当触发元素的事件行为时，让其做某些事

//25. 表单元素input常用的事件行为(4个)
//1) oninput, value值改变时触发
//2) onblur, 失去鼠标焦点
//3) onfocus, 获取鼠标焦点
//4) onchange，内容改变且失去鼠标焦点是，触发

//26. 键盘的常用事件行为(2个)
//1) onkeydown ，键盘按下，输出value值为键盘按下之前的值
//2) onkeyup， 键盘抬起，输出value值为键盘抬起之后最新的值

//27. 鼠标的常用事件行为(10个)
//1) onmouseover 鼠标划上
//2) onmouseout  鼠标离开
//3) onmouseenter 鼠标划上  不会冒泡传播
//4) onmouseleave 鼠标离开  不会冒泡传播
//5) onclick 点击
//6) ondblclick 双击
//7) onmousedown 鼠标按下
//8) onmouseup 鼠标抬起
//9) onmousescroll 鼠标滚轮滚动
//10)

//28. 其他常用的事件行为 (7个)
//1)onscroll 滚轮滚动
//2)onload  加载成功
//3)window.onload  当页面元素都加载完毕时触发
//4)onresize 尺寸发生变化
//5)window.onresize 当浏览器的可视窗口尺寸发生改变时触发
//6)canplay 音视频播放时触发
//7)webkitTransitionEnd 当过渡动画结束时触发

//29. 移动端的常用事件行为(4个)
//1)移动端单手指模型： touchstart  touchmove  touchend
//2)移动端多手指模型： gesturestart  gesturechange  gestureend
//3)移动端事件中，事件对象的距离信息在e.touches的属性名为0的属性值中
//4) touchend的事件对象的距离信息在e.     属性名为0的属性值中

//30. DOM0级事件绑定(4个)
//1)只能给元素的同一事件绑定一个方法
//2)不能控制方法在哪个阶段执行，默认是在冒泡阶段执行
//3)元素.type(带on)=function(){}
//4)
/*oBox.onclick=function () {console.log(1);}
oBox.onclick=function () {console.log(2);}  //点击盒子只会输出2，不会输出1
oBox.onclick=null;*/

//31. DOM2级事件绑定(3个)
//1) 可以给元素的同一事件绑定多个方法
//2) 元素.addEventListener("type",fn,true/false)
//2.1)type,事件类型,不带on
//2.2)fn，绑定的函数
//2.3)true/false 可以控制方法是在哪个阶段执行  true是在捕获阶段执行； false是在冒泡阶段执行
//2.4)方法中的this指向被绑定的元素
//2.5)重复给元素的同一个事件行为绑定相同的方法，只会执行一次
//2.6)不兼容IE8及以下
//2.7)移除绑定,removeEventListener()，三个参数必须与事件绑定时的参数一样
//oBox.addEventListener("click", function () {console.log(3)},false);
//oBox.addEventListener("click", function () {console.log(4)},false);
//oBox.removeEventListener("click", function () {console.log(4)},false);
//3)元素.attachEvent("type",fn)
//3.1)type，事件类型，带on
//3.2)fn，绑定的元素
//3.3)没有第三个参数，无法控制方法是在哪个阶段执行，默认是在冒泡阶段执行
//3.4)方法中的this指向window
//3.5)重复给元素的同一事件行为绑定相同的方法，绑定几次，执行几次
//3.6)谷歌浏览器没有这个方法
//3.7)移除绑定 detachEvent(type,fn)，两个参数必须与事件绑定时的参数一样
//  oBox.attachEvent('onclick',function () {console.log(1)});
//  oBox.attachEvent('onclick',function () {console.log(2)});
//  oBox.detachEvent('onclick',function () {console.log(2)});

//32. addEventListener 和 attachEvent (3个)
//1)顺序问题，前者是先绑定谁，就先执行谁；后者是后绑定谁，就先执行谁；
//2)this问题，前者的this指向被绑定的元素；后者的this指向window
//3)重复绑定问题，前者给元素的同一事件行为绑定同个方法，只会执行一次；后者是绑定多少次，就执行多少次

//33. 事件对象(5个)
//1) 当元素的事件行为绑定的方法执行时，会默认返回一个事件对象给绑定的方法，这个事件对象包含了一些关于此次事件行为的基本信息。
//2) 事件对象e, 在IE8及以下不兼容
//3) 兼容IE8及以下，事件对象放在window的一个属性下, window.event
//4) 兼容性写法： e || window.event
//5)

//34. 一些事件信息(19个)
//1) e.target 事件源;  IE8及以下不兼容
//2) 事件源兼容IE8及以下： e.target= e.target || e.srcElement
//3) e.clientX;  当前位置距离可视窗口的左边框的距离
//4) e.clientY;  当前位置距离可视窗口的上边框的距离
//5) e.offsetX;  当前位置距离事件源的左边框的距离
//6) e.offsetY;  当前位置距离事件源的上边框的距离
//7) e.pageX;    当前位置距离body的左边框的距离，IE8及以下不兼容
//8) e.pageX的兼容性写法： e.pageX = e.pageX || e.clientX + document.documentElement.scrollLeft || document.body.scrollLeft
//9) e.pageY;  当前位置距离body的上边框的距离，IE8及以下不兼容
//10) e.pageY的兼容性写法： e.pageY = e.pageY || e.clientY + document.documentElement.scrollTop || document.body.scrollTop
//11) e.type;  事件类型
//12) e.keyCode; 键盘每个键都对应着一个keyCode值， 左37； 上：38； 右: 39  下：40
//13) e.preventDefault; 阻止事件的默认行为; IE8及以下不兼容
//14) e.preventDefault的兼容性写法： e.preventDefault = e.preventDefault || function(){e.returnValue=false; }
//15) e.stopPropagation; 阻止事件的冒泡传播; IE8及以下不兼容
//16) e.stopPropagation的兼容性写法：e.stopPropagation = e.stopPropagation || function(){e.cancelBubble = true;}

//35. 事件的冒泡传播(2个)
//1)当触发元素的事件行为时，会依次向上触发祖先元素的相应的事件行为，一直触发到window为止
//2)body的冒泡传播过程：body --> html --> document --> window

//36. 事件传播(4个)
//1)事件传播分为三个阶段：捕获阶段 --》目标阶段 --> 冒泡阶段
//2)捕获阶段：从外向里，依次触发从祖先元素到元素在捕获阶段绑定的方法
//3)目标阶段：谁先绑定就先执行谁，false/true对目标阶段没有意义
//4)冒泡阶段：从里向外，依次触发从元素到祖先元素在冒泡阶段绑定的方法

//37. 事件委托(1个)
//1)把方法绑定在最外层元素的事件，当触发里面的元素，由于冒泡传播的特定，也会触发最外层的元素，然后在根据事件源的不同，执行不同的操作即可

//38. setCapture(3个)
//1)火狐、IE浏览器提供的方法 ，可以让鼠标和盒子绑定在一次，无论鼠标移动多快，鼠标都不会脱离盒子
//2)解除绑定的方法： releaseCapture
//3)谷歌浏览器没有这个方法

//39. 可以发送请求的方法有(4个)
//1)浏览器
//2)ajax的实例
//3)src
//4)form表单
/*<form action="https://www.baidu.com/">
    <!--action: 路径-->
    <input type="text" username="">
    <input type="text" password="">
    <input type="submit" id="submit">
    </form>*/













//40. 发布订阅：观察者模式(3个)
//1)
/*
* curEle : 订阅主体；元素
* type: 类型
* fn : 观察者；
 *  */
/*function on(curEle,type,fn) {
    // 初始化一个数组，存放的是观察者；
    if(!curEle[type]){
        // 当第一次进来，初始化一个空数组；
        curEle[type] = [];
    }
    let  ary = curEle[type];
    for(let i=0;i<ary.length;i++){
        // 如果fn出现过，直接停止这次订阅；
        if(fn===ary[i]){
            return;
        }
    }
    ary.push(fn);
}
// 发布；让观察者执行
function selfrun(type) {
    // this---> 订阅主体；
    let  a = this[type];
    for(let i=0;i<a.length;i++){
        if(typeof a[i]==="function"){
            a[i].call(this);
        }
    }
}
// 取消订阅；把在数组中存储的方法移除掉；
function off(curEle,type,fn) {
    let ary = curEle[type];
    for(let i=0;i<ary.length;i++){
        if(fn === ary[i]){
            //ary.splice(i,1); 数组塌陷
            ary[i] = null;
        }
    }
}   */

//41. 严格模式和非严格模式区别(5个)
//1)非严格模式下，arguments与形参存在映射关系，严格模式下，不存在
//2)非严格模式下，call/apply/bind不传参数时，传null，传undefined，this都是指向window；严格模式下，call/apply/bind不传参数，传undefined，this指向undefined，传null，指向null
//3)非严格模式下，如果没有明确的执行主体，this指向window；严格模式下，如果函数没有明确的执行主体，函数中的this指向undefined
//4)严格模式下，不能识别0开头的八进制数字
//5)严格模式下，对只读属性赋值会报错

//42. less(7个)
//1)less叫做预编译css，写好的less代码浏览器是不能渲染的，需要把它编译成为能渲染的css才可以
//2)less中设置变量使用@变量名：变量值，并且变量存在提升的机制，不仅提升，还会赋值
//3)less中变量一般用于存储公用的属性值、公有的url等
//4)不是所有的情况下都要使用变量，只有很多样式都是使用相同的值，而且改变的话，所有元素的样式都要跟着改变，此时才用变量存储起来
//5)less中支持数学运算
//6)在less中只要设置了一个样式类，就可以把它称之为一个方法，其他地方需要用到这些样式时，直接".类名"调用即可。不加括号是普通样式类，也是封装的一个函数

//43. 开发环境与生产环境(2个)
//1)开发环境：本地开发的环境
//2)生产环境：上线后的环境

//44. 本地存储(5个)
//1)localStage，有三个属性  setItem  getItem  removeItem
//2)会话级别的存储sessionStage   setItem  getItem  removeItem


//45. 发布网站的过程(6个)
//1)项目：前端和后端的代码
//2)域名：每个域名是唯一的，不会重复
//3)服务器：每个服务器都会一个唯一的IP地址
//4)DNS解析：
//5)ftp上传工具：可以把本地的项目上传到服务器
//6)端口：服务器会分成一个个的端口，最多有65535个端口，因此端口号的范围是0-65535

//46. http协议(5个)
//1)http: 超文本传输协议
//2)超文本:不仅可以传输文本，也可以传输音频、视频
//3)传输：客户端可以发送数据给服务器，服务器也可以发送数据给客户端
//4)协议：传输的规范
//5)https:更安全的超文本传输协议

//47. 当在浏览器中输入url，向服务器发送请求，浏览器都做了些什么？(3个)
//1)[http 请求阶段]
//1.1)http
//2)[http 响应阶段]
//3)[浏览器渲染阶段]

//48. http事物(1个)
//1)

//49. http的三次握手(5个)
//1)

//50. http的四次挥手(4个)
//1)

//51. http的三次握手和四次挥手的优点(2个)
//1)

//52. 响应头(1个)
//1)

//53. url、uri与urn的区别
//1)

//54. 由什么组成(6个)： http://image.baidu.com/search/index?tn=baiduimage&ps=1&ct=201326592&lm=-1&cl=2&nc=1&ie=utf-8&word=http%E6%98%AF%E4%BB%80%E4%B9%88
//1)










//55. ajax(async javascript and xml)请求的过程(7个)
//1)

//56. xhr.readyState值分别代表什么意思(5个)
//1)

//57. xhr.status; 状态码，代表当前请求的状态(5个)
//1)

//58. ajax的请求方式(5个)
//1)

//59. ajax的同步异步(2个)
//1)

//60. jquery的ajax的参数(8个)
/*$.ajax({
    url :"aside.json",
    type:"get",
    dataType:"json",
    async:true,
    cache:true,
    data:{
        username :  val1,
        password :  val2
    },
    success:function (val) {
        console.log(val);
    },
    error:function (v) {
        console.log(v);// 包含了错误的信息；
    }
})*/
//1)

//61. 怎么样算同源(3个)
//1)

//62. 同源策略和非同源策略(3个)
//1)

//63. JSONP的原理(4个)
//1)
/*function fn(data) {
    console.log(data)
};*/
//<script src="http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&callback=fn"></script>

//64. 全局刷新与局部刷新(2个)
//1)

//65. for of (2个)
//1)
   /* let  ary = [1,2,3];
    for(let key  of  ary){
        console.log(key);// 当前数组成员项；1   2   3
    }
    // 由于对象没有iterator接口，所以不可以循环对象；
    let b = {a:1,b:2};
    for(let key  of  b){
        console.log(key);
    }*/

//65. 数组的方法(6个)
//1)









//66. svn(3个)
//1)集中式的代码管理工具；有一个中央服务器，用来存储所有成员的代码
//2)需要网络才可以把代码上传到中央服务器
//3)上传的是文件

//67. git(4个)
//1)分布式的代码管理工具；每个成员都是一个服务器，也有中央服务器；如果想把本地代码提交到中央服务器，需要先把代码提交到本地的服务器
//2)不需要网络，可以把代码上传到服务器
//3)上传的是数据码；相对于svn更快
//4)有三个区：工作区、暂存区、历史区

//68. git的使用(22个)
//1) git init: 初始化一个git仓库
//2) mkdir 文件名: 创建一个文件夹
//3) touch 1.txt: 创建一个文件(写不同的后缀可以创建不同的文件类型)
//4) cat 文件名: 查看文件内容
//5) cd 文件名: 打开相应的文件夹
//6) cd ./: 同级文件
//7) cd ../: 回到上一级目录
//8) cd /: 回到根目录
//9) clear: 清屏
//10) vi 文件名: 进入文件的编辑模式----> i : 可以进行编辑--->如果想停止：ctrl+c ----> :wq (保存并退出)
//11) git config --list: 查看当前的配置信息
//12) git status: 查看当前仓库文件的状态; 如果文件只在工作区，那么文件颜色是红色的；如果把代码提交到暂存区，没有提交到历史区；那么文件颜色是绿色的
//13) git add ./-A: 把文件上传到暂存区
//14) git rm --cached 文件名: 删除暂存区提交的文件
//15) git checkout 文件名: 把暂存区的代码拉取到本地（工作区），并且把本地（工作区）进行覆盖
//16) git diff: 工作区和暂存区的比较；能看出改了哪一行
//17) git diff --cached: 暂存区和历史区的比较
//18) git diff master: 工作区和历史区比较
//19) git commit -m"注释"： 注释一定要有；把代码从暂存区提交到历史区;
//19.1) 每提交一次到历史区，都会产生一个唯一的版本号；可以根据版本号，把代码回滚到之前的版本
//19.2) 注释： 是对当前修改的代码的一个标识；可以通过注释，回想改的代码
//20) git log: 打印出以往的版本号
//21) git reset --hard 版本号：把历史区之前的版本拉取到工作区；把历史区的代码先拉回到暂存区，再从暂存区拉到工作区；三区一致；历史区和工作区不能直接传输
//22) git add -a -m"": 从工作区提交到历史区中；工作区-->暂存区--->历史区

//69. git的分支(8个)
//1)工作中都会在分支上进行开发项目
//2)主干的代码是没有bug，是经过多轮测试的；和线上的代码是一致的；
//3)在分支上改代码，不会影响到主干上的代码
//4)如果需要创建分支，必须在master上提交到历史区
//5)git branch 分支名: 创建一个分支
//6)git checkout 分支名: 切换分支
//7)git branch: 查看当前仓库所有的分支，并且查看当前在哪个分支上
//8)git merge 分支名: 在主干上去合并分支上的代码；分支上经过了多轮测试

//70. git的远程仓库(6个)
//1) 关联远程仓库：git remote add origin(仓库名) url(远程仓库地址)
//2) 查看和远程仓库的关联: git remote -v
//3) 把历史区的代码推送到远程仓库，只能从历史区推送到远程仓库，空文件夹不进行推送，把本地的代码在中央服务器再备份一下，同时其他成员都可以通过这个地址把你的代码下载下来: git push origin master
//4) 把远程仓库的地址拉取到本地: git clone url(远程仓库地址)
//5) 拉取最新的代码: git pull origin master
//6) 如果多人协作开发，需要添加权限: setting ---> Collaborators ---> add Collaborators


</script>
</body>
</html>